# 데이터 접근 기술 - 시작

## 데이터 접근 기술 진행 방식 소개

**SQLMapper**

- JdbcTemplate
- MyBatis

**ORM 관련 기술**

- JPA, Hibernate
- 스프링 데이터 JPA
- Querydsl

## 프로젝트 설정과 메모리 저장소

프로젝트 설정

## 프로젝트 구조 설명1 - 기본

- `Java 11`
- `Spring Web` `Thymeleaf` `Lombok` `jdbc` `h2`
- `Jar`

**DTO(data transfer object)**

- 데이터 전송 객체
- DTO는 기능은 없고 데이터를 전달만 하는 용도로 사용되는 객체를 뜻한다.
    - 참고로 DTO에 기능이 있으면 안되는가? 그것은 아니다. 객체의 주 목적이 데이터를 전송하는 것이라면 DTO라 할 수 있다.
- 객체 이름에 DTO를 꼭 붙여야 하는 것은 아니다. 대신 붙여두면 용도를 알 수 있다는 장점은 있다.
- 이전에 설명한 ItemSearchCond도 DTO 역할을 하지만, 이 프로젝트에서 Cond는 검색 조건으로
사용한다는 규칙을 정했다. 따라서 DTO를 붙이지 않아도 된다. ItemSearchCondDto 이렇게 하면 너무 복잡해진다. 그리고 Cond라는 것만 봐도 용도를 알 수 있다.
- 참고로 이런 규칙은 정해진 것이 없기 때문에 해당 프로젝트 안에서 일관성 있게 규칙을 정하면 된다.
- DTO의 위치는 DTO가 사용되는 가장 마지막 계층에 위치해두는것이 바람직하다.
- 여러 계층에서 사용하는 등 애매할 경우 따로 패키지를 만들어서 관리.

**ItemService 인터페이스**

- 서비스의 구현체를 쉽게 변경하기 위해 인터페이스를 사용했다.
- 참고로 서비스는 구현체를 변경할 일이 많지는 않기 때문에 사실 서비스에 인터페이스를 잘 도입하지는 않는다.

## 프로젝트 구조 설명2 - 설정

- 서비스와 리포지토리는 구현체를 편리하게 변경하기 위해 수동으로 빈을 등록했다.
- 컨트롤러는 컴포넌트 스캔을 사용한다.

**ItemServiceApplication**

```java
@Slf4j
@Import(MemoryConfig.class)
@SpringBootApplication(scanBasePackages = "hello.itemservice.web")		//Controller만 자동 빈 스캔, 나머지는 수동으로 빈 등록
public class ItemServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(ItemServiceApplication.class, args);
	}

	@Bean
	@Profile("local")
	public TestDataInit testDataInit(ItemRepository itemRepository) {
		return new TestDataInit(itemRepository);
	}

}
```

**MemoryConfig**

```java
@Configuration
public class MemoryConfig {

    @Bean
    public ItemService itemService() {
        return new ItemServiceV1(itemRepository());
    }

    @Bean
    public ItemRepository itemRepository() {
        return new MemoryItemRepository();
    }

}
```

**프로필**
스프링은 로딩 시점에 application.properties의 spring.profiles.active 속성을 읽어서 프로필로 사용한다.
이 프로필은 로컬(나의 PC), 운영 환경, 테스트 실행 등등 다양한 환경에 따라서 다른 설정을 할 때 사용하는 정보이다.
예를 들어서 로컬PC에서는 로컬 PC에 설치된 데이터베이스에 접근해야 하고, 운영 환경에서는 운영
데이터베이스에 접근해야 한다면 서로 설정 정보가 달라야 한다. 심지어 환경에 따라서 다른 스프링 빈을 등록해야 할 수 도 있다. 프로필을 사용하면 이런 문제를 깔끔하게 해결할 수 있다.

참고로 프로필을 지정하지 않으면 디폴트( default ) 프로필이 실행된다.

## 프로젝트 구조 설명3 - 테스트

**인터페이스를 테스트하자**

> 여기서는 MemoryItemRepository 구현체를 테스트 하는 것이 아니라 ItemRepository 인터페이스를 테스트하는 것을 확인할 수 있다. 인터페이스를 대상으로 테스트하면 향후 다른 구현체로 변경되었을 때 해당 구현체가 잘 동작하는지 같은 테스트로 편리하게 검증할 수 있다.
> 

## 데이터베이스 테이블 생성

```java
drop table if exists item CASCADE;
create table item
(
 id bigint generated by default as identity,
 item_name varchar(10),
 price integer,
 quantity integer,
 primary key (id)
);
```

- generated by default as identity
    - identity 전략이고 하는데, 기본 키 생성을 데이터베이스에 위임하는 방법이다. MySQL의 AutoIncrement와 같은 방법이다.
    - 여기서 PK로 사용되는 id는 개발자가 직접 지정하는 것이 아니라 비워두고 저장하면 된다. 그러면 데이터베이스가 순서대로 증가하는 값을 사용해서 넣어준다.

**참고 - 권장하는 식별자 선택 전략**
**데이터베이스 기본 키는 다음 3가지 조건을 모두 만족해야 한다.**

1. null 값은 허용하지 않는다.
2. 유일해야 한다.
3. 변해선 안 된다.

**테이블의 기본 키를 선택하는 전략은 크게 2가지가 있다.**

- 자연 키(natural key)
    - 비즈니스에 의미가 있는 키
    - 예: 주민등록번호, 이메일, 전화번호
- 대리 키(surrogate key)
    - 비즈니스와 관련 없는 임의로 만들어진 키, 대체 키로도 불린다.
    - 예: 오라클 시퀀스, auto_increment, identity, 키생성 테이블 사용

**자연 키보다는 대리 키를 권장한다**
