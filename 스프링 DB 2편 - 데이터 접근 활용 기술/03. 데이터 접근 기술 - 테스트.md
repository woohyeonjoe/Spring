# 데이터 접근 기술 - 테스트

## 테스트 - 데이터베이스 연동

테스트 케이스는 src/test 에 있기 때문에, 실행하면 src/test 에 있는 application.properties
파일이 우선순위를 가지고 실행된다.

**application.properties**

```java
spring.profiles.active=test
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.username=sa
logging.level.org.springframework.jdbc=debug
```

**@SpringBootTest는 @SpringBootApplication를 찾아서 설정으로 사용한다.**

**테스트 코드 실패**

데이터베이스에 이미 과거에 서버를 실행하면서 저장했던 데이터가 보관되어 있기 때문에 테스트 코드가 실패한다.

## 테스트 - 데이터베이스 분리

로컬에서 사용하는 애플리케이션 서버와 테스트에서 같은 데이터베이스를 사용하고 있으니 테스트에서 문제가 발생한다.
이런 문제를 해결하려면 테스트를 다른 환경과 철저하게 분리해야 한다.

**H2 데이터베이스를 용도에 따라 2가지로 구분하면 된다.**
`jdbc:h2:tcp://localhost/~/test` local에서 접근하는 서버 전용 데이터베이스
`jdbc:h2:tcp://localhost/~/testcase` test 케이스에서 사용하는 전용 데이터베이스

**데이터베이스 파일 생성 방법**

- 데이터베이스 서버를 종료하고 다시 실행한다.
- 사용자명은 sa 입력
- JDBC URL에 다음 입력,
- jdbc:h2:~/testcase (최초 한번)
- ~/testcase.mv.db 파일 생성 확인
- 이후부터는 jdbc:h2:tcp://localhost/~/testcase 이렇게 접속

**테스트를 반복하면 데이터가 계속 누적되어서 2회차 테스트부터 또 실패한다.**

**즉, 테스트가 끝나면 데이터를 삭제해야 한다.**

**테스트에서 중요한 원칙**

- 테스트는 다른 테스트와 격리해야 한다.
- 테스트는 반복해서 실행할 수 있어야 한다.

## 테스트 - 데이터 롤백

**트랜잭션과 롤백 전략**

테스트가 끝나고 나서 트랜잭션을 강제로 롤백해버리면 데이터가 깔끔하게 제거된다.

**테스트에 직접 트랜잭션 추가**

```java
@SpringBootTest
class ItemRepositoryTest {
		 @Autowired
		 ItemRepository itemRepository;

		 //트랜잭션 관련 코드
		 @Autowired
		 PlatformTransactionManager transactionManager;
		 TransactionStatus status;

		 @BeforeEach
		 void beforeEach() {
		 //트랜잭션 시작
				 status = transactionManager.getTransaction(new DefaultTransactionDefinition());
		 }

		 @AfterEach
		 void afterEach() {
		 //MemoryItemRepository 의 경우 제한적으로 사용
		 if (itemRepository instanceof MemoryItemRepository) {
				 ((MemoryItemRepository) itemRepository).clearStore();
			 }
				 //트랜잭션 롤백
				 transactionManager.rollback(status);
		 }
		 //...
}
```

## 테스트 - @Transactional

스프링은 테스트 데이터 초기화를 위해 트랜잭션을 적용하고 롤백하는 방식을 @Transactional 애노테이션 하나로 깔끔하게 해결해준다.

**@Transactional 원리**
스프링이 제공하는 @Transactional 애노테이션은 로직이 성공적으로 수행되면 커밋하도록 동작한다.
그런데 @Transactional 애노테이션을 테스트에서 사용하면 아주 특별하게 동작한다.
@Transactional 이 테스트에 있으면 스프링은 테스트를 트랜잭션 안에서 실행하고, 테스트가 끝나면
트랜잭션을 자동으로 롤백시켜 버린다!

> **참고**
테스트 케이스의 메서드나 클래스에 @Transactional을 직접 붙여서 사용할 때 만 이렇게 동작한다. 그리고 트랜잭션을 테스트에서 시작하기 때문에 서비스, 리포지토리에 있는@Transactional 도 테스트에서 시작한 트랜잭션에 참여한다. (이 부분은 뒤에 트랜잭션 전파에서 더 자세히 설명하겠다. 지금은 테스트에서 트랜잭션을 실행하면 테스트 실행이 종료될 때 까지 테스트가 실행하는 모든 코드가 같은 트랜잭션 범위에 들어간다고 이해하면 된다. 같은 범위라는 뜻은 쉽게 이야기해서 같은 트랜잭션을 사용한다는 뜻이다. 그리고 같은 트랜잭션을 사용한다는 것은 같은 커넥션을 사용한다는 뜻이기도 하다.)
> 

**강제로 커밋하기** 

- @Commit
- @Rollback(value = false)

## 테스트 - 임베디드 모드 DB

H2 데이터베이스는 자바로 개발되어 있고, JVM안에서 메모리 모드로 동작하는 특별한 기능을 제공한다. 그래서 애플리케이션을 실행할 때 H2 데이터베이스도 해당 JVM 메모리에 포함해서 함께 실행할 수 있다. DB를 애플리케이션에 내장해서 함께 실행한다고 해서 임베디드 모드(Embedded mode)라 한다.

**메모리 DB에 테이블 만들기**

메모리 DB는 애플리케이션이 종료될 때 함께 사라지기 때문에, 애플리케이션 실행 시점에 데이터베이스 테이블도 새로 만들어주어야 한다.

스프링 부트는 기본 SQL 스크립트를 사용해서 데이터베이스를 초기화하는 기능을 제공.

**src/test/resources/schema.sql**

```sql
drop table if exists item CASCADE;
create table item
(
 id bigint generated by default as identity,
 item_name varchar(10),
 price integer,
 quantity integer,
 primary key (id)
);
```

## 테스트 - 스프링 부트와 임베디드 모드

스프링 부트는 개발자에게 정말 많은 편리함을 제공하는데, 임베디드 데이터베이스에 대한 설정도 기본으로 제공한다.
스프링 부트는 데이터베이스에 대한 별다른 설정이 없으면 임베디드 데이터베이스를 사용한다.

스프링 부트는 임베디드 모드로 접근하는 데이터소스( DataSource )를 만들어서 제공한다.

**결국 테스트 코드 세팅은 두가지만 기억하면 된다.**

1. **application.properties**

```java
spring.profiles.active=test

logging.level.org.springframework.jdbc=debug
```

메모리 DB 사용

1. **@Transactional의 자동롤백을 사용한 반복 테스트 코드**

**+테스트 코드 추가 내용**

[https://www.inflearn.com/questions/675779/이전-임베디드-데이터베이스와-mem-testdb](https://www.inflearn.com/questions/675779/%EC%9D%B4%EC%A0%84-%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%99%80-mem-testdb)
