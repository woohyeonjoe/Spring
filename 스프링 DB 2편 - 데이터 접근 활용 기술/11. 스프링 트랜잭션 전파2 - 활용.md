# 스프링 트랜잭션 전파2 - 활용

## 트랜잭션 전파 활용1 - 예제 프로젝트 시작

**Log, LogRepository, Member, MemberRepository, MemberService 클래스 생성**

## 트랜잭션 전파 활용2 - 커밋, 롤백

**서비스 계층에 트랜잭션이 없을 때 - 커밋**

상황

- 서비스 계층에 트랜잭션이 없다.
- 회원, 로그 리포지토리가 각각 트랜잭션을 가지고 있다.
- 회원, 로그 리포지토리 둘다 커밋에 성공한다.

**서비스 계층에 트랜잭션이 없을 때 - 롤백**
상황

- 서비스 계층에 트랜잭션이 없다.
- 회원, 로그 리포지토리가 각각 트랜잭션을 가지고 있다.
- 회원 리포지토리는 정상 동작하지만 로그 리포지토리에서 예외가 발생한다.

**트랜잭션 AOP(@Transactional)도 결국 내부에서는 트랜잭션 매니저를 사용하게 된다.**

이 경우 회원은 저장되지만, 회원 이력 로그는 롤백된다. 따라서 데이터 정합성에 문제가 발생할 수 있다. 둘을 하나의 트랜잭션으로 묶어서 처리해보자. 

## 트랜잭션 전파 활용3 - 단일 트랜잭션

**트랜잭션 하나만 사용하기**
회원 리포지토리와 로그 리포지토리를 하나의 트랜잭션으로 묶는 가장 간단한 방법은 이 둘을 호출하는 회원 서비스에만 트랜잭션을 사용하는 것이다.

**참고**

같은 쓰레드를 사용하면 트랜잭션 동기화 매니저는 같은 커넥션을 반환한다. (쓰레드풀 때문에 - 고급편 참고)

**하지만 각각 트랜잭션이 필요한 상황에선 어떻게 해야할까?**

![image](https://user-images.githubusercontent.com/106286686/212901939-e46332b3-8560-4bbd-a853-91316c49e62f.png)

- 클라이언트 A는 MemberService 부터 MemberRepository , LogRepository 를 모두 하나의
트랜잭션으로 묶고 싶다.
- 클라이언트 B는 MemberRepository 만 호출하고 여기에만 트랜잭션을 사용하고 싶다.
- 클라이언트 C는 LogRepository 만 호출하고 여기에만 트랜잭션을 사용하고 싶다.

- 클라이언트 A만 생각하면 MemberService 에 트랜잭션 코드를 남기고, MemberRepository,
LogRepository의 트랜잭션 코드를 제거하면 앞서 배운 것 처럼 깔끔하게 하나의 트랜잭션을 적용할 수 있다.
- 하지만 이렇게 되면 클라이언트 B, C가 호출하는 MemberRepository, LogRepository에는 트랜잭션을 적용할 수 없다.

**이런 문제를 해결하기 위해서 트랜잭션 전파가 필요한 것이다.**

## 트랜잭션 전파 활용4 - 전파 커밋

**서비스, 레포지토리(2개) 모두 트랜잭션을 건다.**

**모두 예외 발생 없이 정상로직을 수행하는 경우**

![image](https://user-images.githubusercontent.com/106286686/212901994-a0209859-19d7-4f77-bd9c-ce4b1bf46711.png)

- 이 경우 외부에 있는 신규 트랜잭션만 실제 물리 트랜잭션을 시작하고 커밋한다.
- 내부에 있는 트랜잭션은 물리 트랜잭션 시작하거나 커밋하지 않는다.
- 즉, MemberRepository와 LogRepository는 직접 커밋하지 않고 로직이 무사히 끝나면 MemberService에서 커밋을 하게 된다.

## 트랜잭션 전파 활용5 - 전파 롤백

**서비스, 레포지토리(2개) 모두 트랜잭션을 건다.**

**로그 리포지토리에서 예외가 발생해서 전체 트랜잭션이 롤백되는 경우**

![image](https://user-images.githubusercontent.com/106286686/212902052-b45d9b02-b22d-47e4-bf55-093ffd226ff4.png)

회원과 회원 이력 로그를 처리하는 부분을 하나의 트랜잭션으로 묶은 덕분에 문제가 발생했을 때 회원과 회원 이력 로그가 모두 함께 롤백된다. 따라서 데이터 정합성에 문제가 발생하지 않는다.

## 트랜잭션 전파 활용6 - 복구 REQUIRED

회원 이력 로그를 DB에 남기는 작업에 가끔 문제가 발생해서 회원 가입 자체가 안되는 경우가 가끔 발생하게 되었다. (하나의 레포지토리에서 예외가 발생하면 서비스에서 모두 롤백 처리하기 때문에)

그래서 비즈니스 요구사항이 변경되었다.
**회원 가입을 시도한 로그를 남기는데 실패하더라도 회원 가입은 유지되어야 한다.**

**단순히 생각하면 레포지토리에서 발생한 예외를 서비스에서 잡아서 처리하면 되는것 일까?**

전혀 아니다.

이미 예외가 발생한 레포지토리의 내부 트랜잭션에서 rollbackOnly를 설정하기 때문에 결과적으로 정상 흐름 처리(예외를 잡아서 커밋이 요청되게끔)를 해서 외부 트랜잭션에서 커밋을 호출해도 물리 트랜잭션은 롤백된다. (모두 롤백 처리)

그리고 UnexpectedRollbackException이 던져진다.

## 트랜잭션 전파 활용7 - 복구 REQUIRES_NEW

회원 가입을 시도한 로그를 남기는데 실패하더라도 회원 가입은 유지되어야 한다.

이 요구사항을 만족하기 위해서 로그와 관련된 물리 트랜잭션을 별도로 분리해보자. 바로 REQUIRES_NEW를 사용하는 것이다.

**LogRepository - save()**

```java
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void save(Log logMessage)
```

이렇게 해서 기존 트랜잭션에 참여하는 REQUIRED 대신에, 항상 신규 트랜잭션을 생성하는
REQUIRES_NEW를 적용하자.

![image](https://user-images.githubusercontent.com/106286686/212902127-7ee5309e-9145-4cbc-8838-91e8cab27046.png)

- MemberRepository는 REQUIRED 옵션을 사용한다. 따라서 기존 트랜잭션에 참여한다.
- LogRepository의 트랜잭션 옵션에 REQUIRES_NEW를 사용했다.
- REQUIRES_NEW 는 항상 새로운 트랜잭션을 만든다. 따라서 해당 트랜잭션 안에서는 DB 커넥션도 별도로 사용하게 된다.
- REQUIRES_NEW 를 사용하게 되면 물리 트랜잭션 자체가 완전히 분리되어 버린다.
- 그리고 REQUIRES_NEW 는 신규 트랜잭션이므로 rollbackOnly 표시가 되지 않는다. 그냥 해당
트랜잭션이 물리 롤백되고 끝난다.

**결과적으로 회원 데이터는 저장되고, 로그 데이터만 롤백 되는 것을 확인할 수 있다.**

**주의**
REQUIRES_NEW를 사용하면 하나의 HTTP 요청에 동시에 2개의 데이터베이스 커넥션을 사용하게 된다. 따라서 성능이 중요한 곳에서는 이런 부분을 주의해서 사용해야 한다.
REQUIRES_NEW 를 사용하지 않고 문제를 해결할 수 있는 단순한 방법이 있다면, 그 방법을 선택하는 것이 더 좋다.
