# 스프링 트랜잭션 전파1 - 기본

## 스프링 트랜잭션 전파1 - 커밋, 롤백

**BasicTxTest 생성**

커밋, 롤백 코드 작성

## 스프링 트랜잭션 전파2 - 트랜잭션 두 번 사용

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/332dbcf5-9e6e-4ce8-950b-d07b692cf28a/Untitled.png)

 

**트랜잭션을 2번 실행하는 테스트**

```java
@Test
void double_commit() {
log.info("트랜잭션1 시작");
    TransactionStatus tx1 = txManager.getTransaction(new DefaultTransactionAttribute());
log.info("트랜잭션1 커밋");
    txManager.commit(tx1);

log.info("트랜잭션2 시작");
    TransactionStatus tx2 = txManager.getTransaction(new DefaultTransactionAttribute());
log.info("트랜잭션2 커밋");
    txManager.commit(tx2);
}
```

테스트 코드 실행시 로그를 보면 모두 `conn0` 를 사용해서 같은 커넥션을 사용했다고 오해 할 수 있지만 커밋 후 커넥션을 반납하고 이것을 다시 꺼낸것이므로 다른 커넥션으로 간주한다.

**그러므로 트랜잭션1을 커밋하고 트랜잭션2를 롤백하면 1,2 모두 원하는대로 작동하는 것을 확인 할 수 있다.**

## 스프링 트랜잭션 전파3 - 전파 기본

트랜잭션을 각각 사용하는 것이 아니라, 트랜잭션이 이미 진행중인데, 여기에 추가로 트랜잭션을 수행하면 어떻게 될까?

기존 트랜잭션과 별도의 트랜잭션을 진행해야 할까? 아니면 기존 트랜잭션을 그대로 이어 받아서 트랜잭션을 수행해야 할까?
이런 경우 어떻게 동작할지 결정하는 것을 트랜잭션 전파(propagation)라 한다.

**스프링의 트랜잭션 전파 기본 동작 방식 (REQUIRED)**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/77d27c6e-cda8-4aee-b909-be4f0f24a01c/Untitled.png)

- 외부 트랜잭션이라고 이름 붙인 것은 둘 중 상대적으로 밖에 있기 때문에 외부 트랜잭션이라 한다. 처음 시작된 트랜잭션으로 이해하면 된다.
- **스프링은 이 경우 외부 트랜잭션과 내부 트랜잭션을 묶어서 하나의 트랜잭션을 만들어준다.** 내부 트랜잭션이 외부 트랜잭션에 참여하는 것이다. 이것이 기본 동작이고, 옵션을 통해 다른 동작방식도 선택할 수 있다.

**물리 트랜잭션, 논리 트랜잭션**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/625a85ef-3196-420e-8903-584023948f87/Untitled.png)

- 스프링은 이해를 돕기 위해 논리 트랜잭션과 물리 트랜잭션이라는 개념을 나눈다.
- 물리 트랜잭션은 우리가 이해하는 실제 데이터베이스에 적용되는 트랜잭션을 뜻한다. 실제 커넥션을 통해서 트랜잭션을 시작( setAutoCommit(false)) 하고, 실제 커넥션을 통해서 커밋, 롤백하는 단위이다.
- 논리 트랜잭션은 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위이다.
- 이러한 논리 트랜잭션 개념은 트랜잭션이 진행되는 중에 내부에 추가로 트랜잭션을 사용하는 경우에 나타난다. 단순히 트랜잭션이 하나인 경우 둘을 구분하지는 않는다. (더 정확히는 REQUIRED 전파 옵션을 사용하는 경우에 나타난다.)

**원칙**

- **모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.**
    - 트랜잭션은 항상 순서대로 시작하고, 역순으로 종료해야 한다.
- **하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백된다.**

## 스프링 트랜잭션 전파4 - 전파 예제

```java
@Test
void inner_commit() {
log.info("외부 트랜잭션 시작");
    TransactionStatus outer = txManager.getTransaction(new DefaultTransactionAttribute());
log.info("outer.isNewTransaction()={}", outer.isNewTransaction());      //처음 수행된 트랜잭션인가?

    //이전 트랜잭션 커밋이나 롤백하기전에 트랜잭션 하나 더 실행
log.info("내부 트랜잭션 시작");
    TransactionStatus inner = txManager.getTransaction(new DefaultTransactionAttribute());
log.info("inner.isNewTransaction()={}", inner.isNewTransaction());
log.info("내부 트랜잭션 커밋");
    txManager.commit(inner);

log.info("외부 트랜잭션 커밋");
    txManager.commit(outer);
}
```

**트랜잭션 참여**

- 내부 트랜잭션이 외부 트랜잭션에 참여한다는 뜻은 내부 트랜잭션이 외부 트랜잭션을 그대로 이어 받아서 따른다는 뜻이다.
- 다른 관점으로 보면 외부 트랜잭션의 범위가 내부 트랜잭션까지 넓어진다는 뜻이다.
- 외부에서 시작된 물리적인 트랜잭션의 범위가 내부 트랜잭션까지 넓어진다는 뜻이다.
- 정리하면 외부 트랜잭션과 내부 트랜잭션이 하나의 물리 트랜잭션으로 묶이는 것이다.
- 기존 트랜잭션에 참여한다는 뜻은 사실 아무것도 하지 않는다는 뜻이다.
    - 트랜잭션을 만들지 않는다.
    - 트랜잭션 동기화 매니저에 있는 기존 커넥션을 꺼낸다. (기존(외부) 트랜잭션이 넣어둔 커넥션)

**위와 같이 실행하면 물리 트랜잭션 하나로 묶인다 했다. 그런데 왜 트랜잭션 커밋을 두번이나 했는데 문제가 없을까?**

- 실제 로그를 보면 내부 트랜잭션 커밋시 아무일도 일어나지 않는다.
- 외부 트랜잭션을 커밋해야 진짜 커밋이 일어난다.
- 트랜잭션이 내부에서 추가로 사용되면, 트랜잭션 매니저를 통해 논리 트랜잭션을 관리하고, 모든 논리 트랜잭션이 커밋되면 물리 트랜잭션이 커밋된다고 이해하면 된다.

**로그 분석**

- 내부 트랜잭션을 시작할 때 Participating in existing transaction 이라는 메시지를 확인할 수
있다. 이 메시지는 내부 트랜잭션이 기존에 존재하는 외부 트랜잭션에 참여한다는 뜻이다.
- 외부 트랜잭션만 물리 트랜잭션을 시작하고, 커밋한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3ba4ae3c-7f77-4434-8f7b-852e9c5545a8/Untitled.png)

## 스프링 트랜잭션 전파5 - 외부 롤백

**내부 트랜잭션은 커밋되는데, 외부 트랜잭션이 롤백되는 상황**

논리 트랜잭션이 하나라도 롤백되면 전체 물리 트랜잭션은 롤백된다.
따라서 이 경우 내부 트랜잭션이 커밋했어도, 내부 트랜잭션 안에서 저장한 데이터도 모두 함께 롤백된다.

## 스프링 트랜잭션 전파6 - 내부 롤백

**내부 트랜잭션은 롤백되는데, 외부 트랜잭션이 커밋되는 상황**

**테스트 코드가 에러를 발생시킨다.**

**로그분석**

- 외부 트랜잭션 시작
    - 물리 트랜잭션을 시작한다.
- 내부 트랜잭션 시작
    - Participating in existing transaction
    - 기존 트랜잭션에 참여한다.
- 내부 트랜잭션 롤백
    - Participating transaction failed - marking existing transaction as rollbackonly
    - 내부 트랜잭션을 롤백하면 실제 물리 트랜잭션은 롤백하지 않는다. 대신에 기존 트랜잭션을 롤백 전용으로 표시한다. (트랜잭션 동기화 매니저에 표시)
- 외부 트랜잭션 커밋
    - 외부 트랜잭션을 커밋한다.
    - Global transaction is marked as rollback-only
    - 커밋을 호출했지만, 전체 트랜잭션이 롤백 전용으로 표시되어 있다. 따라서 물리 트랜잭션을 롤백한다.

**스프링은 이 경우 UnexpectedRollbackException 런타임 예외를 던진다. 그래서 커밋을 시도했지만, 기대하지 않은 롤백이 발생했다는 것을 명확하게 알려준다.**

## 스프링 트랜잭션 전파7 - REQUIRES_NEW

외부 트랜잭션과 내부 트랜잭션을 완전히 분리해서 사용하는 방법에 대해서 알아보자.

외부 트랜잭션과 내부 트랜잭션을 완전히 분리해서 각각 별도의 물리 트랜잭션을 사용하는 방법이다. 그래서 커밋과 롤백도 각각 별도로 이루어지게 된다.

**REQUIRES_NEW**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e11d53ed-696a-4435-9f20-b4c6d62481aa/Untitled.png)

- 이렇게 물리 트랜잭션을 분리하려면 내부 트랜잭션을 시작할 때 REQUIRES_NEW 옵션을 사용하면 된다.
- 외부 트랜잭션과 내부 트랜잭션이 각각 별도의 물리 트랜잭션을 가진다.
- 별도의 물리 트랜잭션을 가진다는 뜻은 DB 커넥션을 따로 사용한다는 뜻이다.
- 이 경우 내부 트랜잭션이 롤백되면서 로직 2가 롤백되어도 로직 1에서 저장한 데이터에는 영향을 주지 않는다.
- 최종적으로 로직2는 롤백되고, 로직1은 커밋된다.

**요청 흐름 - REQUIRES_NEW**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/58f8f5e2-025c-4138-940a-2d1c1d999ecf/Untitled.png)

1. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관한다.
    - 이때 con1은 잠시 보류되고, 지금부터는 con2가 사용된다. (내부 트랜잭션을 완료할 때 까지con2가 사용된다.)

**응답 흐름 - REQUIRES_NEW**

1. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 롤백한다.
2. 내부 트랜잭션이 con2 물리 트랜잭션을 롤백한다.
    - 트랜잭션이 종료되고, con2 는 종료되거나, 커넥션 풀에 반납된다.
    - 이후에 con1 의 보류가 끝나고, 다시 con1을 사용한다.
3. 외부 트랜잭션에 커밋을 요청한다.
4. 본인이 만든 con1 커넥션을 통해 물리 트랜잭션을 커밋한다.
    - 트랜잭션이 종료되고, con1 은 종료되거나, 커넥션 풀에 반납된다.
 
